# Les Signaux

### Différents moyens de communiquer sous unix

+ signaux
+ pipes
+ pipes nommées
+ mémoire partagée

### Moyens non spécifiques à unix

+ sockets

## Les Signaux

Il en existe de différents types:
- envoyé par le système pour avertir d'un événement particulier ou d'une rreur pendant l'exécution d'un processus (par exemple la mort d'un fils, une erreur d'adressage mémoire)
- envoyé par un programme utilisateur (ou directement par l'utilisateur depuis son shell)

Il y a plusieurs signaux "standards" disponibles grâce à la commande `kill -l`.

À la réception d'un signal, le sytème fait appel à un handler. Les signaux `SIGINT`, `SIGKILL`, `SIGUSR1` et `SIGUSR2` ont par exemple un handler qui termine le processus. `SIGSEGV` provoque un *core dumped* et `SIGCHLD` est ignoré.  
On peut définir un handler personnalisé.

### Envoyer un signal

```c
#include <sys/types.h>
#include <signal.h>
int kill (pid_t pid, int sig);
```

### Changer le handler d'origine
```c
void (*signal (int sig, void (*disp)(int))) (int)
```
La fonction prend en paramètre le numéro du signal et une fonction *handler* qui était précédemment associé au signal.  
Une fonction *handler* prend en paramètre un entier (le numéro du signal reçu) et ne retourne rien.

Il existe des *handlers* pré-définis:
+ `SIG_DFL`: handler par défaut du signal
+ `SIG_IGN`: handler qui ignore le signal

#### Exemple
```c
#include <sys/types.h>
#include <signal.h>

void my_handler(int n) {
    printf("J'ai reçu le signal %d", n);
}

int main(void){
    pid_t mypid;

    mypid = getpid();

    signal(SIGUSR1, SIG_IGN);
    signal(SIGCHLD, my_handler);

    kill(mypid, SIGUSR1);
    kill(mypid, SIGCHLD);           // "J'ai reçu le signal 17"
    kill(mypid, SIGINT);            // Interruption du processus

}
```

Un processus peut se bloquer en attendant de recevoir un signal avec:
```c
#include <unistd.h>

int pause(void);    // continue sauf si un handler l'arrête
```

On peut attendre la mort d'un fils avec `wait()`.

Quand un signal est envoyé, il devient *pendant* (pending). Au bout d'un certain temps, le système déclenche tous les handlers associés aux *signaux pendants* pour un processus.  
Dans l'espace mémoire du système, il y a un vecteur de bits associé à chaque processus. Chaque bit correspond à un signal. Si le bit est à 1, le signal correspondant est *pendant*.

> Notes:
> + Il est impossible de prévoir à l'avance le délai entre l'envoi et la réception du signal.  
> + Si deux signaux identiques sont envoyés, un seul est comptabilisé.

La table des handlers fait partie de l'espace système. Les fils de ce processus héritent de l'ensemble des handlers de leur père.

## Les Tubes

Les tubes sont des structures de programmation de type FIFO.

### En créer

```c
#include <unistd.h>

int pipe (int p_desc[2]);   // 0 si OK, -1 sinon
```

### Lecture et écriture

Elles se font par l'intermédiaire des primitives *read* et *write*.  
`p_desc[0]` contient le numéro du descripteur dans lequel on peut lire.  
`p_desc[1]` contient le numéro du descripteur dans lequel on peut écrire.

### Fermeture

La fermeture d'un descripteur de tube se fait par l'intermédiaire de la primitive classique *close*.  
Pour qu'un tube soit complètement fermé, il faut que **TOUS** les processus ayant connaissance de ce tube l'aient fermé.

La fonction *close* sur les tubes est plus important que sur les fichiers car, non seulement elle libère un descripteur, mais, lorsque le descripteur d'écriture est fermé, cela agit comme une fin de fichier pour le lecteur. Un `\0` est placé en fin de fichier.

## La duplication de descripteur

```c
#include <unistd.h>
int dup(int p_desc);
```

Cette commande permet de créer une copie du descripteur donné en paramètre. La copie est effectuée dans le plus petit numéro de descripteur libre.  
Cette fonction retourne le numéro du nouveau descripteur si la copie s'est biben passée, -1 sinon.

#### Exemple d'utilisation: Re-direction temporaire de la sortie standard vers un fichier

```c
{
    int tempout, newout,oldout;

    tempout=open("sortie_temporaire",O_WRONLY);
    oldout=dup(1);
    close(1);
    newout=dup(tempout);    /* renvoie 1 */
    printf("xxxx");         /* écriture dans le fichier temporaire */
    close(tempout);
    close(1);
    newout=dup(oldout);
    close(oldout);
}
```

ls | more  
avant firk, rediriger le ls : close(1); dup(tube[1]); close(tube[1]); fork()  
more close(0); dup(tube[0]); close(tube[0]); close(tube(1)); fork(); newout

### Autre fonction

```c
#include <unistd.h>
int dup2(int source, int destination);
```

Recopie du descripteur source dans l'entrée destination de la table des descripteurs. Si destintion désigne un descripteur déjà utilisé, celui-ci est préalablement fermé avant duplication.

## Les pipes nommés

Les pipes ont parfois un inconvénient: on ne peut faire communiquer ensemble que deux processus qui ont un ancêtre commun.  
Les **pipes nommés** (également appelés FIFOs) permettent à deux processus *quelconques* de communiquer, pourvu qu'ils se mettent d'accord sur une adresse de rendez-vous commune.  
Un pipe nommé est un type de fichier particulier: un processus peut écrire dedans. Quand un autre processus le lit, *la lecture est destructrice*.

### Pour créer un FIFO

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
```

*path* est le nom du FIFO; *mode* décrit les droits d'accès au FIFO (généralement en octal).  
*mkfifo* retourne -1 en cas d'erreur.

### Ouvrir un pipe nommé

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *path, int oflag);
```
*path* le nom du fifo; *oflag* le mode d'ouverture du fifo _O_*_

*open* bloque le processus appelant tnt qu'un second processus n'a pas ouvert l'autre extrémité du FIFO.

## Les IPC System-V

### Commandes shell

+ `ipcs`: status des IPCs actifs
+ `ipcrm`: détruire un IPC (`ipcrm -s semid` ou `ipcrm -m shmid`)

### Primitives

+ Sémaphores:
  + `semget()`: créer un sémaphore
  + `semop()`: opérations sur les sémaphores
  + `semctl()`: contrôle les sémaphores
+ Mémoire partagée:
  + `shmget()`: créer un segment de mémoire partagée
  + `shmat()`: attacher un segmenet de mémoire partagée
  + `shmdt()`: détacher un segment de mémoire partagée
  + `shmctl()`: contrôler des segments de mémoire partagée

#### `semget()`

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semget(key_t key, int nsems, int semflg);
```

*key* est le point de rendez-vous entre plusieurs processus qui veulent partager un sémaphore. (*IPC_PRIVATE* créé des sémaphores accessibles seulement aux descendants du processus courant).  
*nsems*: taille du tableau de sémaphores  
*semflg*: drapeaux
  + Droits d'accès (ex: 0600, 0660, 0640)
  + `IPC_CREAT`, `IPC_EXCL`

semget(key, 1, 0600) $\rightarrow$ id si existe  
semget(key, 1, 0600|IPC_CREAT)$\rightarrow$ id si existe ou non  
semget(key, 1, 0600|IPC_CREAT|IPC_EXCL) $\rightarrow$ id si n'existe pas, -1 sinon

#### `semop()`

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semop(int semid, struct sembuf *sops, size_t nsops);
struct sembuf {
    short sem_num; /* semaphore number */
    short sem_op; /* semaphore operation */
    short semflg; /* operation flags */
}
```
*semif* identificateur du tableau  
*sops* tableau de'oprations à effectuer  
*nops* nombre d'opérations  

*sem_num* numéro du sémaphore dans le tableau  
*semop* opération à réaliser  
  + = 0: attendre jusqu'à ce que le sem soir égal à 0.
  + \> 0: incrémenter
  + < 0: décrémenter  

*sem_flg* drapeaux
  +  0: mode normal
  +  IPC_NOWAIT: mode non bloquant

L'ensemble des opération est réalisé de façon atomique.

### Contrôles des sémaphores

#### `semctl()`

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semctl(int semid, int semnum, int cmd, ...);
```
*semid* identificateur  
*semnum* numéro du sémaphore dans le tableau  
*cmd*:
+ GETVAL: retourne la valeur du sem
+ SETVAL: initialise la valeur du sem avecle 4e paramètre
+ IPC_RMID: détruit le tableau de sémaphores. Il faut toujours détruire les sémaphores créés autrement qu'avec IPC_PRIVATE.

### Exemple de programme

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

main() {
    struct sembuf up = {0, 1, 0};
    struct sembuf down = {0, -1, 0};
    int my_sem, valeur;

    my_sem = semget(IPC_PRIVATE, 1, 0600);   /*    creation    */
    semctl(my_sem, 0, SETVAL, 1);           /* positionne à 1 */
    semop(my_sem, &down, 1);                /*     down()     */
    valeur = semctl(my_sem, 0, GETVAL);     /* lire la valeur */
    semop(my_sem, &up, 1);                  /*      up()      */
    semctl(my_sem, 0, IPC_RMID);            /*   destruction  */
}
```
Quand on le peut, on utilise *IPC_PRIVATE* sinon il y a `ftok()`.
```c
#include <sys/types.h>
#include <sys/ipc.h>
key_t ftok(const char *path, int id);
```
*path* point de rdv  
*id* entier identifiant le projet