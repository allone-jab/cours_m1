# Les Signaux

### Différents moyens de communiquer sous unix

+ signaux
+ pipes
+ pipes nommées
+ mémoire partagée

### Moyens non spécifiques à unix

+ sockets

## Les Signaux

Il en existe de différents types:
- envoyé par le système pour avertir d'un événement particulier ou d'une rreur pendant l'exécution d'un processus (par exemple la mort d'un fils, une erreur d'adressage mémoire)
- envoyé par un programme utilisateur (ou directement par l'utilisateur depuis son shell)

Il y a plusieurs signaux "standards" disponibles grâce à la commande `kill -l`.

À la réception d'un signal, le sytème fait appel à un handler. Les signaux `SIGINT`, `SIGKILL`, `SIGUSR1` et `SIGUSR2` ont par exemple un handler qui termine le processus. `SIGSEGV` provoque un *core dumped* et `SIGCHLD` est ignoré.  
On peut définir un handler personnalisé.

### Envoyer un signal

```c
#include <sys/types.h>
#include <signal.h>
int kill (pid_t pid, int sig);
```

### Changer le handler d'origine
```c
void (*signal (int sig, void (*disp)(int))) (int)
```
La fonction prend en paramètre le numéro du signal et une fonction *handler* qui était précédemment associé au signal.  
Une fonction *handler* prend en paramètre un entier (le numéro du signal reçu) et ne retourne rien.

Il existe des *handlers* pré-définis:
+ `SIG_DFL`: handler par défaut du signal
+ `SIG_IGN`: handler qui ignore le signal

#### Exemple
```c
#include <sys/types.h>
#include <signal.h>

void my_handler(int n) {
    printf("J'ai reçu le signal %d", n);
}

int main(void){
    pid_t mypid;

    mypid = getpid();

    signal(SIGUSR1, SIG_IGN);
    signal(SIGCHLD, my_handler);

    kill(mypid, SIGUSR1);
    kill(mypid, SIGCHLD);           // "J'ai reçu le signal 17"
    kill(mypid, SIGINT);            // Interruption du processus

}
```

Un processus peut se bloquer en attendant de recevoir un signal avec:
```c
#include <unistd.h>

int pause(void);    // continue sauf si un handler l'arrête
```

On peut attendre la mort d'un fils avec `wait()`.

Quand un signal est envoyé, il devient *pendant* (pending). Au bout d'un certain temps, le système déclenche tous les handlers associés aux *signaux pendants* pour un processus.  
Dans l'espace mémoire du système, il y a un vecteur de bits associé à chaque processus. Chaque bit correspond à un signal. Si le bit est à 1, le signal correspondant est *pendant*.

> Notes:
> + Il est impossible de prévoir à l'avance le délai entre l'envoi et la réception du signal.  
> + Si deux signaux identiques sont envoyés, un seul est comptabilisé.

La table des handlers fait partie de l'espace système. Les fils de ce processus héritent de l'ensemble des handlers de leur père.

## Les Tubes

Les tubes sont des structures de programmation de type FIFO.

### En créer

```c
#include <unistd.h>

int pipe (int p_desc[2]);   // 0 si OK, -1 sinon
```

### Lecture et écriture

Elles se font par l'intermédiaire des primitives *read* et *write*.  
`p_desc[0]` contient le numéro du descripteur dans lequel on peut lire.  
`p_desc[1]` contient le numéro du descripteur dans lequel on peut écrire.

### Fermeture

La fermeture d'un descripteur de tube se fait par l'intermédiaire de la primitive classique *close*.  
Pour qu'un tube soit complètement fermé, il faut que **TOUS** les processus ayant connaissance de ce tube l'aient fermé.

La fonction *close* sur les tubes est plus important que sur les fichiers car, non seulement elle libère un descripteur, mais, lorsque le descripteur d'écriture est fermé, cela agit comme une fin de fichier pour le lecteur. Un `\0` est placé en fin de fichier.

## La duplication de descripteur

```c
#include <unistd.h>
int dup(int p_desc);
```

Cette commande permet de créer une copie du descripteur donné en paramètre. La copie est effectuée dans le plus petit numéro de descripteur libre.  
Cette fonction retourne le numéro du nouveau descripteur si la copie s'est biben passée, -1 sinon.

#### Exemple d'utilisation: Re-direction temporaire de la sortie standard vers un fichier

```c
{
    int tempout, newout,oldout;

    tempout=open("sortie_temporaire",O_WRONLY);
    oldout=dup(1);
    close(1);
    newout=dup(tempout);    /* renvoie 1 */
    printf("xxxx");         /* écriture dans le fichier temporaire */
    close(tempout);
    close(1);
    newout=dup(oldout);
    close(oldout);
}
```

ls | more  
avant firk, rediriger le ls : close(1); dup(tube[1]); close(tube[1]); fork()  
more close(0); dup(tube[0]); close(tube[0]); close(tube(1)); fork(); newout

### Autre fonction

```c
#include <unistd.h>
int dup2(int source, int destination);
```

Recopie du descripteur source dans l'entrée destination de la table des descripteurs. Si destintion désigne un descripteur déjà utilisé, celui-ci est préalablement fermé avant duplication.